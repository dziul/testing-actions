# @ref [semantic-release](https://github.com/semantic-release/semantic-release)
# @ref [nextrelease](https://github.com/semantic-release/semantic-release/blob/master/docs/developer-guide/js-api.md#nextrelease)
# @ref [js api](https://semantic-release.gitbook.io/semantic-release/developer-guide/js-api)

name: "Semantic Versioning"
description: "Release tag and badge versioning"

# @ref [action-branding](https://actions-cool.github.io/github-action-branding/)
branding:
  icon: 'tag'
  color: 'purple'
  
inputs:
  config_file_path:
    description: "Configuration file from semantic-release"
    required: false
    type: string
    default: ''
  dry_run:
    description: "The objective of the dry-run mode is to get a preview of the pending release."
    required: false
    type: boolean
    default: false
    
outputs:
  version:
    description: "The version of the last release"
    value: ${{ steps.checking.outputs.version }}
  channel:
    description: "The distribution channel on which the last release was initially made available (undefined for the default distribution channel)"
    value: ${{ steps.checking.outputs.version }}
 

runs:
  using: "composite"
  steps:
    - uses: actions/checkout@v3
    
    - uses: actions/setup-node@v3
      with:
        node-version: 16
    - name: Checking exists configuration file and release version
      id: checking
      shell: bash
      run: |
        CONFIG_FILENAME=".releaserc"
        CONTENT='{"branches":["main","master"],"plugins":["@semantic-release/commit-analyzer","@semantic-release/release-notes-generator"]}'
        if [ -f "${{ inputs.config_file_path }}" ]; then
          CONTENT=$(cat ${{ inputs.config_file_path }})
          
          ### Checking if the configuration is in package.json
          if [ $(echo $CONTENT | jq 'has("release")') ]; then
            CONTENT=$(echo $CONTENT | jq '.release')
          fi
          if [[ ! "${{ inputs.config_file_path }}" =~ "package*" ]]; then
            rm -f ${{ inputs.config_file_path }}
          fi
          ###
          
        fi
        
        TEMP_FILE="${RANDOM}_${{ github.sha }}.txt"
        echo $CONTENT | jq \
        --arg config_file $CONFIG_FILENAME \
        --arg file_temp $TEMP_FILE \
        '.plugins|= .+ [["@semantic-release/exec",{"analyzeCommitsCmd":" echo \"last_version::${lastRelease.version}\" >> \($file_temp | tojson)", "verifyConditionsCmd": "rm -f \($config_file | tojson)", "successCmd": "echo \"next_version::${nextRelease.version}\">>\($file_temp | tojson) && echo \"channel::${nextRelease.channel}\">>\($file_temp | tojson)"}]]' > $CONFIG_FILENAME
        NPX_PACKAGES="$(echo $CONTENT | jq '.plugins|map(if type=="array" then .[0] else . end) | unique | reduce .[] as $item ("-y"; . + " -p " + $item)') -p @semantic-release/exec"
        NPX_FLAGS="-d ${{ inputs.dry_run }}"
        eval "npx $NPX_PACKAGES semantic-release $FLAGS"
        
        
        while IFS= read -r line; do
          echo "::set-output name=$line"
        done < "$TEMP_FILE"
        rm -f "$TEMP_FILE"
        
    - shell: bash
      run: |
        echo "${{ toJSON(steps.checking) }}"
        
       
      
      
